//+------------------------------------------------------------------+
//| SUSTAI_AI_Bot.mq5 |
//| Copyright 2025, SUSTAI Labs |
//| Generated by SUSTAI Bot Builder |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, SUSTAI Labs"
#property link "https://sustai.io"
#property version "1.00"
#property description "Generated by SUSTAI Labs Bot Builder - Compile-Safe MQ5 EA with AI Integration"
#property strict

//--- IMPORTANT: Enable WebRequest in MT5
//--- Tools → Options → Expert Advisors → "Allow WebRequest for listed URLs"
//--- Add: http://127.0.0.1:5000/chat

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| Input Parameters |
//+------------------------------------------------------------------+
input group "=== Bot Configuration ==="
input string TradingSymbol = "BTCUSD"; // Trading symbol
input ENUM_TIMEFRAMES InpTimeframe = PERIOD_M15; // Analysis timeframe
input int MagicNumber = 12345; // Magic number
input int CooldownSeconds = 60; // Cooldown between trades

input group "=== AI Configuration ==="
input bool UseAI = true; // Enable AI signals
input string AIEndpoint = "http://127.0.0.1:5000/chat"; // AI relay endpoint
input double ConfidenceThreshold = 0.7; // Min confidence
input bool UseLocalFallback = true; // Use local signals if AI fails

input group "=== Risk Management ==="
input double MaxRiskPercent = 2.0; // Max risk per trade (%)
input int StopLossPips = 0; // Stop loss in pips
input int TakeProfitPips = 10000000; // Take profit in pips
input bool OnePositionPerSymbol = true; // One position per symbol

//+------------------------------------------------------------------+
//| Global Variables |
//+------------------------------------------------------------------+
int rsiHandle = INVALID_HANDLE;
int macdHandle = INVALID_HANDLE;
int emaHandle = INVALID_HANDLE;
datetime lastTradeTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization function |
//+------------------------------------------------------------------+
int OnInit() {
    Print("SUSTAI_AI_Bot v1.00 initializing...");
    
    // Validate and select trading symbol
    if(!SymbolSelect(TradingSymbol, true)) {
        Print("ERROR: Symbol ", TradingSymbol, " not found on this broker");
        return(INIT_FAILED);
    }
    
    // Initialize indicators with the specified symbol and timeframe
    rsiHandle = iRSI(TradingSymbol, InpTimeframe, 14, PRICE_CLOSE);
    macdHandle = iMACD(TradingSymbol, InpTimeframe, 12, 26, 9, PRICE_CLOSE);
    emaHandle = iMA(TradingSymbol, InpTimeframe, 21, 0, MODE_EMA, PRICE_CLOSE);
    
    // Check indicator handles
    if(rsiHandle == INVALID_HANDLE || macdHandle == INVALID_HANDLE || emaHandle == INVALID_HANDLE) {
        Print("ERROR: Failed to initialize indicators");
        return(INIT_FAILED);
    }
    
    // Setup trading
    trade.SetExpertMagicNumber(MagicNumber);
    trade.SetTypeFillingBySymbol(TradingSymbol);
    trade.SetDeviationInPoints(10);
    
    Print("SUSTAI_AI_Bot initialized successfully");
    Print("Symbol: ", TradingSymbol, " | Timeframe: ", EnumToString(InpTimeframe));
    Print("AI Enabled: ", UseAI, " | Endpoint: ", AIEndpoint);
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    // Release indicator handles
    if(rsiHandle != INVALID_HANDLE) IndicatorRelease(rsiHandle);
    if(macdHandle != INVALID_HANDLE) IndicatorRelease(macdHandle);
    if(emaHandle != INVALID_HANDLE) IndicatorRelease(emaHandle);
    Print("SUSTAI_AI_Bot deinitialized. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function |
//+------------------------------------------------------------------+
void OnTick() {
    // New bar detection - only trade once per bar
    static datetime lastBarTime = 0;
    datetime currentBarTime = iTime(TradingSymbol, InpTimeframe, 0);
    if(lastBarTime < currentBarTime) {
        lastBarTime = currentBarTime;
        CheckForSignals();
    }
}

//+------------------------------------------------------------------+
//| Check for trading signals |
//+------------------------------------------------------------------+
void CheckForSignals() {
    // Cooldown check
    if(TimeCurrent() - lastTradeTime < CooldownSeconds) return;
    
    // One position per symbol check
    if(OnePositionPerSymbol && PositionSelect(TradingSymbol)) return;
    
    string signal = "hold";
    double confidence = 0.0;
    
    // Try AI signal first
    if(UseAI && !MQLInfoInteger(MQL_TESTER)) {
        if(GetAISignal(signal, confidence)) {
            if(confidence >= ConfidenceThreshold) {
                ExecuteSignal(signal, confidence);
                return;
            }
        } else if(!UseLocalFallback) {
            return; // AI failed and no fallback
        }
    }
    
    // Fallback to local signals
    if(!UseAI || UseLocalFallback || MQLInfoInteger(MQL_TESTER)) {
        if(GetLocalSignal(signal, confidence)) {
            ExecuteSignal(signal, confidence);
        }
    }
}

//+------------------------------------------------------------------+
//| Get AI signal via WebRequest |
//+------------------------------------------------------------------+
bool GetAISignal(string &signal, double &confidence) {
    // Get indicator values
    double rsi[1], macdMain[1], ema[1];
    if(CopyBuffer(rsiHandle, 0, 1, 1, rsi) < 1 ||
       CopyBuffer(macdHandle, 0, 1, 1, macdMain) < 1 ||
       CopyBuffer(emaHandle, 0, 1, 1, ema) < 1) {
        return false;
    }
    
    // Build JSON payload
    string jsonPayload = StringFormat(
        "{\"symbol\":\"%s\",\"timeframe\":\"%s\",\"rsi\":%.2f,\"macd_main\":%.6f,\"ema\":%.5f,\"time\":%d}",
        TradingSymbol, EnumToString(InpTimeframe), rsi[0], macdMain[0], ema[0], (int)TimeCurrent()
    );
    
    // Convert to uchar array
    uchar postData[];
    StringToCharArray(jsonPayload, postData, 0, -1, CP_UTF8);
    
    // Prepare WebRequest
    string headers = "Content-Type: application/json\r\n";
    uchar result[];
    string responseHeaders;
    
    ResetLastError();
    int response = WebRequest(
        "POST", AIEndpoint, headers, 5000, // 5 second timeout
        postData, result, responseHeaders
    );
    
    if(response == -1) {
        int error = GetLastError();
        Print("WebRequest failed. Error: ", error, ". Ensure URL is whitelisted in MT5 settings.");
        return false;
    }
    
    if(response != 200) {
        Print("AI server error. HTTP code: ", response);
        return false;
    }
    
    // Parse response
    string responseText = CharArrayToString(result);
    return ParseAIResponse(responseText, signal, confidence);
}

//+------------------------------------------------------------------+
//| Parse AI response JSON |
//+------------------------------------------------------------------+
bool ParseAIResponse(const string response, string &signal, double &confidence) {
    // Simple JSON parsing for expected format:
    // {"action":"buy|sell|hold","confidence":0.0-1.0,"reason":"text"}
    int actionPos = StringFind(response, "\"action\":");
    if(actionPos == -1) return false;
    
    int actionStart = StringFind(response, "\"", actionPos + 9);
    int actionEnd = StringFind(response, "\"", actionStart + 1);
    if(actionStart == -1 || actionEnd == -1) return false;
    
    signal = StringSubstr(response, actionStart + 1, actionEnd - actionStart - 1);
    
    int confPos = StringFind(response, "\"confidence\":");
    if(confPos != -1) {
        int confStart = confPos + 13;
        int confEnd = StringFind(response, ",", confStart);
        if(confEnd == -1) confEnd = StringFind(response, "}", confStart);
        if(confEnd != -1) {
            string confStr = StringSubstr(response, confStart, confEnd - confStart);
            confidence = StringToDouble(confStr);
        }
    }
    
    return (signal == "buy" || signal == "sell" || signal == "hold");
}

//+------------------------------------------------------------------+
//| Get local fallback signal |
//+------------------------------------------------------------------+
bool GetLocalSignal(string &signal, double &confidence) {
    double rsi[2];
    if(CopyBuffer(rsiHandle, 0, 1, 2, rsi) < 2) return false;
    
    signal = "hold";
    confidence = 0.6; // Default confidence for local signals
    
    // Simple RSI crossback strategy
    if(rsi[1] < 30 && rsi[0] >= 30) {
        signal = "buy";
        return true;
    } else if(rsi[1] > 70 && rsi[0] <= 70) {
        signal = "sell";
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Execute trading signal |
//+------------------------------------------------------------------+
void ExecuteSignal(const string signal, const double confidence) {
    if(signal == "hold") return;
    
    MqlTick tick;
    if(!SymbolInfoTick(TradingSymbol, tick)) {
        Print("ERROR: Failed to get tick data for ", TradingSymbol);
        return;
    }
    
    double price = (signal == "buy") ? tick.ask : tick.bid;
    double lotSize = CalculateLotSize(price);
    if(lotSize <= 0) {
        Print("ERROR: Invalid lot size calculated");
        return;
    }
    
    double sl = CalculateStopLoss(signal, price);
    double tp = CalculateTakeProfit(signal, price);
    string comment = StringFormat("SUSTAI_AI_Bot %s (%.1f%%)", signal, confidence * 100);
    
    bool result = false;
    if(signal == "buy") {
        result = trade.Buy(lotSize, TradingSymbol, price, sl, tp, comment);
    } else if(signal == "sell") {
        result = trade.Sell(lotSize, TradingSymbol, price, sl, tp, comment);
    }
    
    if(result) {
        lastTradeTime = TimeCurrent();
        Print("Trade executed: ", signal, " | Lot: ", lotSize, " | SL: ", sl, " | TP: ", tp, " | Confidence: ", confidence);
    } else {
        uint errorCode = trade.ResultRetcode();
        Print("Trade failed: ", signal, " | Error: ", errorCode, " - ", trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| Calculate lot size based on risk |
//+------------------------------------------------------------------+
double CalculateLotSize(const double price) {
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double riskAmount = balance * (MaxRiskPercent / 100.0);
    
    // Get pip information
    int digits = (int)SymbolInfoInteger(TradingSymbol, SYMBOL_DIGITS);
    double point = SymbolInfoDouble(TradingSymbol, SYMBOL_POINT);
    double pipSize = (digits == 3 || digits == 5) ? point * 10 : point;
    
    double slDistance = StopLossPips * pipSize;
    double tickValue = SymbolInfoDouble(TradingSymbol, SYMBOL_TRADE_TICK_VALUE);
    
    if(slDistance == 0 || tickValue == 0) return SymbolInfoDouble(TradingSymbol, SYMBOL_VOLUME_MIN);
    
    double lotSize = riskAmount / (slDistance / point * tickValue);
    
    // Normalize lot size
    return NormalizeLotSize(lotSize);
}

//+------------------------------------------------------------------+
//| Calculate stop loss |
//+------------------------------------------------------------------+
double CalculateStopLoss(const string signal, const double price) {
    if(StopLossPips <= 0) return 0;
    
    int digits = (int)SymbolInfoInteger(TradingSymbol, SYMBOL_DIGITS);
    double point = SymbolInfoDouble(TradingSymbol, SYMBOL_POINT);
    double pipSize = (digits == 3 || digits == 5) ? point * 10 : point;
    
    // Get minimum stop level
    int stopLevel = (int)SymbolInfoInteger(TradingSymbol, SYMBOL_TRADE_STOPS_LEVEL);
    double minDistance = (stopLevel + 5) * point; // Add 5 point buffer
    
    double slDistance = MathMax(StopLossPips * pipSize, minDistance);
    double sl = (signal == "buy") ? price - slDistance : price + slDistance;
    
    return NormalizeDouble(sl, digits);
}

//+------------------------------------------------------------------+
//| Calculate take profit |
//+------------------------------------------------------------------+
double CalculateTakeProfit(const string signal, const double price) {
    if(TakeProfitPips <= 0) return 0;
    
    int digits = (int)SymbolInfoInteger(TradingSymbol, SYMBOL_DIGITS);
    double point = SymbolInfoDouble(TradingSymbol, SYMBOL_POINT);
    double pipSize = (digits == 3 || digits == 5) ? point * 10 : point;
    
    // Get minimum stop level
    int stopLevel = (int)SymbolInfoInteger(TradingSymbol, SYMBOL_TRADE_STOPS_LEVEL);
    double minDistance = (stopLevel + 5) * point; // Add 5 point buffer
    
    double tpDistance = MathMax(TakeProfitPips * pipSize, minDistance);
    double tp = (signal == "buy") ? price + tpDistance : price - tpDistance;
    
    return NormalizeDouble(tp, digits);
}

//+------------------------------------------------------------------+
//| Normalize lot size to broker requirements |
//+------------------------------------------------------------------+
double NormalizeLotSize(double lots) {
    double minLot = SymbolInfoDouble(TradingSymbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(TradingSymbol, SYMBOL_VOLUME_MAX);
    double lotStep = SymbolInfoDouble(TradingSymbol, SYMBOL_VOLUME_STEP);
    
    if(minLot <= 0) minLot = 0.01;
    if(maxLot <= 0) maxLot = 100.0;
    if(lotStep <= 0) lotStep = 0.01;
    
    // Ensure lot is within bounds
    lots = MathMax(lots, minLot);
    lots = MathMin(lots, maxLot);
    
    // Round to lot step
    lots = MathFloor(lots / lotStep) * lotStep;
    
    // Get lot digits for normalization
    int lotDigits = 2;
    if(lotStep >= 1.0) lotDigits = 0;
    else if(lotStep >= 0.1) lotDigits = 1;
    else if(lotStep >= 0.01) lotDigits = 2;
    else lotDigits = 3;
    
    return NormalizeDouble(lots, lotDigits);
}
//+------------------------------------------------------------------+